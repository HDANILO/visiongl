
/** vglCudaCopy

    Copy of image in cuda context.
*/

// <<<input->shape[VGL_HEIGHT],384>>> (IO_PBO: VglImage* input, IO_PBO: VglImage* output)
// (input->cudaPtr, output->cudaPtr, input->shape[VGL_WIDTH], input->shape[VGL_HEIGHT], input->nChannels)

template<typename T> 
__global__ void global_Copy(T* input, T* output, int w, int h, int nChannels){
    int offset = blockIdx.x * nChannels * w;
    T* arr_in  = input + offset;
    T* arr_out = output + offset;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      arr_out[j] = arr_in[j];
    }
}

/** vglCudaInvert

    Inverts image stored in cuda context.
*/

// <<<input->shape[VGL_HEIGHT],384>>> (IN_PBO: VglImage* input, OUT_PBO: VglImage* output)
// (input->cudaPtr, output->cudaPtr, input->shape[VGL_WIDTH], input->shape[VGL_HEIGHT], input->nChannels)

template<typename T> 
__global__ void global_Invert(T* input, T* output, int w, int h, int nChannels){
    int offset = blockIdx.x * nChannels * w;
    T* array_in  = input  + offset;
    T* array_out = output + offset;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      array_out[j] = -array_in[j];
    }
}



/** vglCudaInvertOnPlace

    Inverts image, stored in cuda context, on place.
*/

// <<<input->shape[VGL_HEIGHT],384>>> (IO_PBO: VglImage* input)
// (input->cudaPtr, input->shape[VGL_WIDTH], input->shape[VGL_HEIGHT], input->nChannels)

  template<typename T> 
  __global__ void global_InvertOnPlace(T* input, int w, int h, int nChannels){
    T* array = input + blockIdx.x * nChannels * w;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      array[j] = -array[j];
    }
  }
